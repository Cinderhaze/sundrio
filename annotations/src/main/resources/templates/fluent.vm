package ${model.type.packageName};

import me.builder.Fluent;
#foreach($i in $model.imports)
import $i;
#end
#if ( ${model.type.superClass})
#if (${model.superClass.packageName} != ${model.type.packageName})
import ${model.superClas.packageName}.${model.superClass.className};
#end#end
public class ${model.type.className}Fluent<T extends ${model.type.className}Fluent<T>>#if ( ${model.superClass}) extends ${model.superClass.className}Fluent<T>#end implements Fluent<T> {

#foreach($f in $model.fields)
#if (${f.type.arrayType})
    private final List<${f.type.className}> ${f.name} = new ArrayList<>();

    public T ${f.withSetter}(${f.type.simpleName} ${f.name}) {
        for (${f.type.className} item : ${f.name}) {
            this.${f.name}.add(item);
        }
        return (T) this;
    }

    public T ${f.addSetter}(${f.type.className} ${f.name}) {
        this.${f.name}.add(${f.name});
        return (T) this;
    }

    public ${f.type.simpleName} ${f.getter}() {
        return ${f.name}.toArray(new ${f.type.className}[${f.name}.size()]);
    }
#else
    private ${f.type.simpleName} ${f.name};

    public T ${f.withSetter}(${f.type.simpleName} ${f.name}) {
        this.${f.name}=${f.name};
        return (T) this;
    }

    public ${f.type.simpleName} ${f.getter}() {
        return ${f.name};
    }
#end

#if (${f.buildable})
    public ${f.nestedClassName}<T> ${f.addSetter}() {
        return new ${f.nestedClassName}<T>();
    }

    class ${f.nestedClassName}<N> extends ${f.type.className}Fluent<${f.nestedClassName}<N>> implements Nested<N> {
        private final ${f.type.className}Builder builder = new ${f.type.className}Builder();

        @Override
        public N and() {
#if (${f.type.arrayType})
            return (N) ${f.addSetter}(builder.build());
#else
            return (N) ${f.withSetter}(builder.build());
#end
        }
    }
#end    
#end
}