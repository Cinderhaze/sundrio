package ${model.type.packageName};

import me.builder.Fluent;
#foreach($i in $model.imports)
import $i;
#end
#if ( ${model.type.superClass})
#if (${model.superClass.packageName} != ${model.type.packageName})
import ${model.superClas.packageName}.${model.superClass.className};
#end#end
public class ${model.type.className}Fluent<T extends ${model.type.className}Fluent<T>>#if ( ${model.superClass}) extends ${model.superClass.className}Fluent<T>#end implements Fluent<T> {

#foreach($f in $model.fields)
#if (${f.type.arrayType})
    private final List<${f.type.className}> ${f.name} = new ArrayList<>();

    public T ${f.withSetter}(${f.type.simpleName} ${f.name}) {
        for (${f.type.className} item : ${f.name}) {
            this.${f.name}.add(item);
        }
        return (T) this;
    }

    public T ${f.addSetter}(${f.type.className} ${f.name}) {
        this.${f.name}.add(${f.name});
        return (T) this;
    }

    public ${f.type.simpleName} ${f.getter}() {
        return ${f.name}.toArray(new ${f.type.className}[${f.name}.size()]);
    }
#else
    private ${f.type.simpleName} ${f.name};

    public T ${f.withSetter}(${f.type.simpleName} ${f.name}) {
        this.${f.name}=${f.name};
        return (T) this;
    }

    public ${f.type.simpleName} ${f.getter}() {
        return ${f.name};
    }
#end
#end

#foreach($n in $model.nestedTypes)
    class ${n.className}Nested<T> extends ${n.className}Fluent<${n.className}Nested<T>> implements Nested<T> {
        private final ${n.className}Builder builder = new ${n.className}Builder();

        @Override
        public T  and() {
            return (T) add${n.className}(builder.build());
        }
    }
#end
}